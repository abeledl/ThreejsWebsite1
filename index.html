<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Load GLTF in Three.js</title>
    <style>
        body {
            overflow: hidden;
            margin: 0;
            background: linear-gradient(0deg, #face8d 50%, aquamarine 100%);
        }
    </style>
</head>
<body>
    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/controls/OrbitControls.js",
            "three/addons/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/loaders/GLTFLoader.js",
            "three/addons/loaders/RGBELoader.js": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/loaders/RGBELoader.js",
            "three/addons/postprocessing/EffectComposer.js": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/postprocessing/EffectComposer.js",
            "three/addons/postprocessing/RenderPass.js": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/postprocessing/RenderPass.js",
            "three/addons/postprocessing/SSRPass.js": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/postprocessing/SSRPass.js"
        }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { SSRPass } from 'three/addons/postprocessing/SSRPass.js';
  

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z =5;
        camera.position.y = 4;
        camera.position.x = 0;
        camera.lookAt(0, 50, 0);

        const renderer = new THREE.WebGLRenderer({alpha: true, antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        //renderer.shadowMap.type = THREE.PCFSoftShadowMap;  // Enable soft shadows
        //renderer.toneMapping = THREE.ACESFilmicToneMapping;  // Tone mapping
        renderer.toneMappingExposure = 0.9;
        renderer.outputEncoding = THREE.sRGBEncoding;  // Set color encoding
        document.body.appendChild(renderer.domElement);

        //renderer.setClearColor(0x000000, 0);
        

        // Load HDR environment map
        /*
        new RGBELoader().load('ml_gradient_freebie_01.hdr', (hdrTexture) => {
            hdrTexture.mapping = THREE.EquirectangularReflectionMapping;  // Set mapping type
            scene.environment = hdrTexture;  // Set environment
            scene.background = hdrTexture;   // Set as background
        });*/
        
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
pmremGenerator.compileEquirectangularShader();
const textureLoader = new THREE.TextureLoader();
textureLoader.load('bluegradient.jpg', (jpgTexture) => {
    jpgTexture.mapping = THREE.EquirectangularReflectionMapping;

    // Preprocess for better lighting
    const envMap = pmremGenerator.fromEquirectangular(jpgTexture).texture;

    scene.environment = envMap;
    scene.background = envMap;

    // Clean up PMREM resources
    pmremGenerator.dispose();
});

        


        
        // Load GLTF model
        const loader = new GLTFLoader();
        loader.load("lv1.glb", function (gltf) {
            // Enable shadow casting and receiving for the GLTF model
            gltf.scene.traverse(function(node) {
                if (node.isMesh) {
                    //node.castShadow = true;    // Objects will cast shadows
                    //node.receiveShadow = true; // Objects will receive shadows
                }
            });
            scene.add(gltf.scene);
        }, undefined, function (error) {
            console.error(error);
        });

        loader.load("level2.glb", function (gltf) {
            // Enable shadow casting and receiving for the GLTF model
            gltf.scene.traverse(function(node) {
                if (node.isMesh) {
                    //node.castShadow = true;    // Objects will cast shadows
                    //node.receiveShadow = true; // Objects will receive shadows
                }
            });
            scene.add(gltf.scene);
        }, undefined, function (error) {
            console.error(error);
        });
        renderer.physicallyCorrectLights = true;


        // Add sphere with lighting-affected material
        const sphere = new THREE.Mesh(
            new THREE.SphereGeometry(1, 1, 1),
            new THREE.MeshStandardMaterial({ color: 0x008000 })  
        );
        sphere.position.set(2, 4, 0);
        sphere.castShadow = true;    // Sphere casts shadows
        sphere.receiveShadow = true; // Sphere receives shadows
        //scene.add(sphere);
        
        


        // Add lights
        let ambientLight = new THREE.AmbientLight(0xffffff, 0);
        scene.add(ambientLight);
        
        let sun = new THREE.DirectionalLight(0xffffff, 1.5);
        sun.position.set(20, 20, 10);  // Move sun light to a different position
        sun.target.position.set(0, 0, -10);
        //sun.castShadow = true;  // Enable shadows for directional light
        
        // Set up shadow properties for the sun
        sun.shadow.mapSize.width = 1024;  // Increase shadow map size for better quality
        sun.shadow.mapSize.height = 1024;
        sun.shadow.camera.near = 0.1;
        sun.shadow.camera.far = 500;
        sun.shadow.camera.left = -50;
        sun.shadow.camera.right = 50;
        sun.shadow.camera.top = 50;
        sun.shadow.camera.bottom = -50;
        sun.shadow.bias = -0.0005;  // Try adjusting this value
        
        scene.add(sun);

        //add point light blue
        let pointLight = new THREE.PointLight(0x0000ff, 1, 100);
        pointLight.position.set(2, 4, 0);

        // Add grid
        //const grid = new THREE.GridHelper(100, 100, 0x000000, 0x000000);
        //grid.receiveShadow = true; // Grid receives shadows
        //scene.add(grid);


        // Orbit controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 4, 0);


        
        
        // Set up EffectComposer and post-processing passes
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        // Set up SSR Pass
        const ssrPass = new SSRPass({
            renderer,
            scene,
            camera,
            width: window.innerWidth,
            height: window.innerHeight,
            groundReflector: null,  // If you want to add ground reflections
            selects: null           // Specify selective objects for SSR if needed
        });
        ssrPass.thickness = 0.01;
        ssrPass.infiniteThick = false;
        ssrPass.maxDistance = 2;
        ssrPass.resolution = 0.01; // Adjust this value to balance performance and quality

        composer.addPass(ssrPass);

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
                // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera); 
            //composer.render();
        }
        
        animate();
        
        
    </script>
</body>
</html>
